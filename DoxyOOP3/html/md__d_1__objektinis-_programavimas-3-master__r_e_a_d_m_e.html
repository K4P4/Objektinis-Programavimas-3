<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OOP3: Naudojimosi instrukcijos:</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OOP3
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Naudojimosi instrukcijos: </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Versijoms iki v0.4 yra sukurtas makefile esantis pagrindiniame aplanke, naudojantis g++ kompiliatoriumi, linux sistemoje, reikia:</p><ul>
<li>Konsolėje atsidaryti aplanką</li>
<li>make</li>
<li>./main</li>
</ul>
<h1>V0.4 failo generavimas, skirstymas bei išvedimas su 10 pažymių kiekvienam studentui užtruko:</h1>
<ul>
<li><code>0,001s su 10 studentų -</code>0,004s su 100 studentų</li>
<li><code>0,029s su 1000 studentų -</code>0,281s su 10000 studentų</li>
<li>`2,781s su 100000 studentų</li>
</ul>
<p>Kad išbandyti šį generavimą, programos meniu lange reikia pasirinkti 4 variantą</p>
<h1>V0.5 Studentų išskirstymas su 10 pažymių kiekvienam studentui užtruko:</h1>
<h2>std::vector</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">Trukmė   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.092s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.913s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.998s   </td></tr>
</table>
<h2>std::deque</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">Trukmė   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.086s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.865s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.458s   </td></tr>
</table>
<h2>std::list</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">Trukmė   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.091s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.889s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.869s   </td></tr>
</table>
<p>Tokiai paprastai užduočiai, kaip duomenų nuskaitymas ir dėjimas į naujus struktūrų masyvus, pagal atliktus matavimus labiausiai tinka deque konteineris, kuris net puse sekundės sparčiau atlieka darbą už vektorių dirbant su 1000000 dydžio masyvu. List konteineris beveik tiksliai užima vidurį tarp deque ir vector, nuo vieno atsilikdamas panašiai kiek lenkdamas kitą. Programoje nėra manipuliuojama duomenimis jau esančiais masyvuose, todėl išmatuotas yra tik duomenų pridėjimo į skirtingą konteinerį efektyvumas.</p>
<p>Naudoti cpp failai pateikti konteineriams atitinkamo pavadinimo aplankuose</p>
<h1>V1.0 Studentų išskirstymas su 10 pažymių kiekvienam studentui užtruko:</h1>
<h2>std::vector</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">1 Strategija  </th><th class="markdownTableHeadNone">2 Strategija   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s  </td><td class="markdownTableBodyNone">0.002s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.088s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.092s  </td><td class="markdownTableBodyNone">7.829s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.913s  </td><td class="markdownTableBodyNone">788.002s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.998s  </td><td class="markdownTableBodyNone"><em>Per ilgai</em>   </td></tr>
</table>
<p>Labai greitai ižvelgiamas didelis vector konteinerio minusas - elementų trynimas. Kadangi ištrynus elementą visi po jo esantys elementai turi būti perkopijuojami per vieną vietą, gauname jog esant dideliam elementų, o tai reiškia ir trynimų skaičiui, programos veikimo laikas pailgėja net iki 863 kartų (su 100000 duomenų). Nors naudojamos atminties kiekis sumažėja dvigubai (vietoje trijų konteinerių, kuriuose yra kiekvienas elementas du kartus, turime du konteinerius, kuriuose jie nesikartoja) tai, mano manymu, neatperka tokio milžininško veikimo laiko pailgėjimo, o jei atmintis tampa didele problema, tuomet reiktų naudoti vector konteinerio alternatyvas arba stl algoritmus.</p>
<h2>std::deque</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">1 Strategija  </th><th class="markdownTableHeadNone">2 Strategija   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s  </td><td class="markdownTableBodyNone">0.002s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.042s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.086s  </td><td class="markdownTableBodyNone">3.294s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.865s  </td><td class="markdownTableBodyNone">324.294s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.458s  </td><td class="markdownTableBodyNone"><em>Per ilgai</em>   </td></tr>
</table>
<p>Deque konteinerio situacija panaši kaip ir vector, veikimo laikas lyginant su 1 strategija didėja eksponentiškai. Tačiau lyginant su vector, veikimo laikas yra du kartus trumpesnis, tai yra todėl, kad deque pasižymi savybe išsiskirstyti duomenis į daugiau nei vieną blokus. Rezultatas tas, kad, ištrynus tam tikrą elementą reikia perkopijuoti ne visus elementus, o tik tuos esančius tame pačiame atminties bloke. Nors tai šiek tiek ir pagerina situaciją, bet vis dėlto, tikrai nėra efektyvus sprendimas.</p>
<h2>std::list</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">1 Strategija  </th><th class="markdownTableHeadNone">2 Strategija   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.001s  </td><td class="markdownTableBodyNone">0.001s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.008s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.091s  </td><td class="markdownTableBodyNone">0.082s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.889s  </td><td class="markdownTableBodyNone">0.811s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.869s  </td><td class="markdownTableBodyNone">8.038s   </td></tr>
</table>
<p>Priešingai nei kiti du konteineriai, list tampa netgi efektyvesnis naudojantis antra strategija, kadangi elementai yra išdėstyti ne vienas šalia kito blokuose, o sujungti vienas su kitu double linked list pagrindu. Tai reiškia, jog nors ir priėjimas prie konkretaus elemento yra lėtesnis, bet kai jis prieitas trynimas tėra rodyklės nukreipimas, kas yra labai pigus veiksmas laiko atžvilgiu. Mūsų atveju, kuomet vistiek turi būti iteruoti visi elementai, list konteinerio lėtesnis priėjimas prie elemento tampa nesvarbus ir naudojantis antra strategija tai yra pats sparčiausias užduoties atlikimo būdas.</p>
<p>Naudoti cpp failai pateikti konteineriams atitinkamo pavadinimo aplankuose</p>
<h1>Algoritmų bandymas</h1>
<h2>find_if</h2>
<p>Pritaikius find_if algoritmą antrąjai strategijai pavidalu: </p><div class="fragment"><div class="line">vector&lt;stud&gt;::iterator it = studentai.begin();</div><div class="line">    it = std::find_if(it, studentai.end(), maziau);</div><div class="line">    while(it != studentai.end()){</div><div class="line">        vargs.push_back(*it);</div><div class="line">        it = studentai.erase(it);</div><div class="line">        it = std::find_if(it, studentai.end(), maziau);</div><div class="line">    }</div></div><!-- fragment --><p> kur <em>maziau</em> tai: </p><div class="fragment"><div class="line">bool maziau(const stud&amp; esm){</div><div class="line">return (esm.vidurkis &lt; 5.0);</div><div class="line">}</div></div><!-- fragment --><p> Gaunami tokie laikai:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">Su find_if()  </th><th class="markdownTableHeadNone">Be algoritmo   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">0.002s  </td><td class="markdownTableBodyNone">0.002s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.088s  </td><td class="markdownTableBodyNone">0.088s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">7.698s  </td><td class="markdownTableBodyNone">7.829s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">794.87s  </td><td class="markdownTableBodyNone">788.002s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone"><em>Per ilgai</em>  </td><td class="markdownTableBodyNone"><em>Per ilgai</em>   </td></tr>
</table>
<p>Matoma, jog algoritmas veikimo ženkliai nepaspartino.</p>
<h2>copy_if + remove_if</h2>
<div class="fragment"><div class="line">std::copy_if(studentai.begin(), studentai.end(), std::back_inserter(vargs), maziau);</div><div class="line">it = std::remove_if(studentai.begin(), studentai.end(), maziau);</div><div class="line">studentai.erase(it, studentai.end());</div><div class="line">studentai.shrink_to_fit();</div></div><!-- fragment --><p> Palyginimas su 1-ąja strategija:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">copy_if+remove_if  </th><th class="markdownTableHeadNone">1 Strategija   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.092s  </td><td class="markdownTableBodyNone">0.092s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.893s  </td><td class="markdownTableBodyNone">0.913s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.847s  </td><td class="markdownTableBodyNone">8.998s   </td></tr>
</table>
<p>Padidėjo ir sparta ir išspręsta nenaudojamos atminties problema lyginant su pirmąja strategija.</p>
<h2>partition ir stable_partition</h2>
<div class="fragment"><div class="line">vector&lt;stud&gt;::iterator it = studentai.begin();</div><div class="line"></div><div class="line">it = std::stable_partition(studentai.begin(), studentai.end(), maziau);</div><div class="line">vector&lt;stud&gt; kieti(it, studentai.end());</div><div class="line"></div><div class="line">studentai.erase(it, studentai.end());</div><div class="line">studentai.shrink_to_fit();</div></div><!-- fragment --><p>Palyginimas su 1-ąja strategija:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">stable_partition  </th><th class="markdownTableHeadNone">partition  </th><th class="markdownTableHeadNone">1 Strategija   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.009s  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.098s  </td><td class="markdownTableBodyNone">0.093s  </td><td class="markdownTableBodyNone">0.092s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.973s  </td><td class="markdownTableBodyNone">0.904s  </td><td class="markdownTableBodyNone">0.913s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">9.499s  </td><td class="markdownTableBodyNone">8.701s  </td><td class="markdownTableBodyNone">8.998s   </td></tr>
</table>
<p>Pastebima, jog stable_partition yra lėtesnis už 1-ąją strategiją, o partition šiek tiek greitesnis. Partition greitesnis už 1-ąją strategiją todėl, kad nereikia ieškoti ką kopijuoti iteruojant per visą vektorių, kopijuojamas yra visas blokas elementų. O stable_partition atsilieka, nes rikiuojant jis išlaiko originalią elementų eilės tvarką.</p>
<h2>greičiausias būdas: partition be kopijavimo</h2>
<div class="fragment"><div class="line">vector&lt;stud&gt;::iterator it = studentai.begin();</div><div class="line">it = std::partition(studentai.begin(), studentai.end(), maziau);</div></div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">Trukmė   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000  </td><td class="markdownTableBodyNone">0.009s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.086s   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.838s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000  </td><td class="markdownTableBodyNone">8.197s   </td></tr>
</table>
<p>Nekuriant dviejų vektorių, o tiesiog prisimenant iteratorių, ties kuriuo prasideda "kieti" studentai, yra sutaupoma daug laiko, tačiau manipuliacija vektoriais gali būti sudėtingesnė. Pvz. jeigu norėsime funkcijai perduoti "kietus" studentus, turėsime perduoti visą bendrą vektorių ir iteratorių.</p>
<h1>Papildoma užduotis</h1>
<p>## Funkcija su vector </p><div class="fragment"><div class="line">vector&lt;stud&gt; iterpkKietus(vector&lt;stud&gt;&amp; studentai){</div><div class="line">    vector&lt;stud&gt; minksti;</div><div class="line">    vector&lt;stud&gt;::size_type i = 0;</div><div class="line">    vector&lt;stud&gt;::size_type it = 0;</div><div class="line">    while (i != studentai.size()) {</div><div class="line">      if (gavoSkola(studentai[i])) {</div><div class="line">        minksti.push_back(studentai[i]);</div><div class="line">      } else{</div><div class="line">        studentai[it] = studentai[i];</div><div class="line">        ++it;</div><div class="line">      }</div><div class="line">      ++i;</div><div class="line">    }</div><div class="line">    studentai.resize(it);</div><div class="line">    studentai.shrink_to_fit();</div><div class="line">    return minksti;</div><div class="line">}</div></div><!-- fragment --><h2>Funkcija su deque</h2>
<div class="fragment"><div class="line">vector&lt;stud&gt; raskMinkstus(deque&lt;stud&gt;&amp; studentai){</div><div class="line">    vector&lt;stud&gt; minksti;</div><div class="line">    int it = 0;</div><div class="line">    int n = studentai.size();</div><div class="line">    for(int i = 0; i &lt; n; i++) {</div><div class="line">      if(gavoSkola(studentai[i])){</div><div class="line">        minksti.push_back(studentai[i]);</div><div class="line">      } else{</div><div class="line">        studentai.push_front(studentai[i]);</div><div class="line">        ++it;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    studentai.resize(it);</div><div class="line">    studentai.shrink_to_fit();</div><div class="line">    return minksti;</div><div class="line">}</div></div><!-- fragment --><h2>Rezultatai</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">RaskMinkstus()  </th><th class="markdownTableHeadNone">IterpkKietus() Vector  </th><th class="markdownTableHeadNone">IterpkKietus() Deque   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">7.764s  </td><td class="markdownTableBodyNone">0.092s  </td><td class="markdownTableBodyNone">0.091s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">795.47s  </td><td class="markdownTableBodyNone">0.916s  </td><td class="markdownTableBodyNone">0.876s   </td></tr>
</table>
<p>Pastebimas milžiniškas spartos padidėjimas naudojant <code>IterpkKietus()</code> funckiją palyginus su <code>RaskMinkstus()</code>. Tai įvyksta dėl tos pačios priežasties, dėl kurios <em>list</em> buvo greitesnis palyginus su kitais konteineriais V1.0 testavimo metu, nes nebereikia perkopijuoti elementų vieną iš jų ištrynus. Šis būdas leidžia <em>vector</em> ir <em>deque</em> turėti tiek spartą, tiek atsikratyti nenaudojamos atminties užimtumo. Tarp <em>vector</em> ir <em>deque</em> pastebimas labai nedidelis spartos skirtumas, tačiau <em>deque</em> atveju pačios funkcijos veikimo metu yra naudojama daugiau atminties.</p>
<h1>V1.1</h1>
<p>Vector folderyje pridėta realizacija naudojant <code>stud</code> klasę vietoj struktūros Naudojant <code>std::partition</code> palyginimas tarp realizacijos su klase ir su struktūra:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">klasė  </th><th class="markdownTableHeadNone">struktūra   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.093s  </td><td class="markdownTableBodyNone">0.093s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.916s  </td><td class="markdownTableBodyNone">0.904s   </td></tr>
</table>
<p>Pastebimas minimalus veikimo laiko pailgėjimas kai duomenų skaičius siekia 100000</p>
<h2>Optimization flags</h2>
<p>Rezultatai naudojant O1, O2 ir O3 optimization flag'us:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Studentų skaičius  </th><th class="markdownTableHeadNone">default  </th><th class="markdownTableHeadNone">O1  </th><th class="markdownTableHeadNone">O2  </th><th class="markdownTableHeadNone">O3   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">0.093s  </td><td class="markdownTableBodyNone">0.067s  </td><td class="markdownTableBodyNone">0.066s  </td><td class="markdownTableBodyNone">0.066s   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000  </td><td class="markdownTableBodyNone">0.916s  </td><td class="markdownTableBodyNone">0.648s  </td><td class="markdownTableBodyNone">0.647s  </td><td class="markdownTableBodyNone">0.646s   </td></tr>
</table>
<p>Matoma, jog <code>-O1</code> optimization flag'as paspartino programos veikimą beveik trečdaliu, o sekantys palyginus su pirmuoju pastebimo skirtumo nepadarė. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
